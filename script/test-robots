#!/usr/bin/env python3
"""
A script to run a test competition match on every robot in an submissions directory.

A "broken" robot is any robot which:
- Fails to reach the wait_start function within the 5 second timeout
  set in wait_until_robots_ready, caused by:
  a. The robot code throwing an uncaught exception before instantiating the Robot
  b. The robot code taking over 5 seconds before instantiating the Robot
- Fails to complete a 1 second match within the subprocess timout
- Causes the simulator to exit with a non-zero exit code
"""
import sys
import time
import shutil
import argparse
import tempfile
import subprocess
from typing import List
from pathlib import Path

REPO_ROOT = Path(__file__).resolve().parent.parent

sys.path.insert(1, str(REPO_ROOT / 'modules'))

from controller_utils import NUM_ZONES  # isort:skip

EXCESS_SUBPROCESS_TIMEOUT = 10


def test_webots_runtime(comp_match_script: str, temp_archives: Path) -> int:
    """
    Run a empty webots match to determine the expected duration of a successful match.
    temp_archives are used to recieve the logs and animations.
    """
    try:
        print("Running an empty match")  # noqa:T001

        match_args = [
            sys.executable,
            comp_match_script,
            str(temp_archives),
            '0',  # no logs will be retained so a fixed match number is used
        ]

        match_args.extend(['-'] * NUM_ZONES)  # make all zones empty

        match_args.extend([
            '--duration', '1',
            '--no-record',
        ])

        start_time = time.time()
        subprocess.run(
            match_args,
            check=True,
            stdout=subprocess.PIPE,  # we only want to print output if it fails
            stderr=subprocess.STDOUT,
        )

        print("Completed an empty match")  # noqa:T001

    except subprocess.CalledProcessError as match_errors:
        print(match_errors.output.decode())  # noqa: T001
        print("Webots failed on an empty match")  # noqa:T001
        raise

    return round(time.time() - start_time)


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser()
    parser.add_argument(
        'archives_dir',
        help=(
            "The directory containing the teams' robot code, as Zip archives "
            "named for the teams' TLAs."
        ),
        type=Path,
    )
    return parser.parse_args()


def main(args: argparse.Namespace) -> None:
    failed_tlas: List[str] = []

    run_comp_match = str(Path(__file__).parent / 'run-comp-match')

    with tempfile.TemporaryDirectory() as tempdir_name:

        tempdir = Path(tempdir_name)
        # Make a temporary copy of the archives to receive the logs
        archives = shutil.copytree(args.archives_dir.resolve(), tempdir / 'archives')

        subprocess_timeout = EXCESS_SUBPROCESS_TIMEOUT + test_webots_runtime(
            run_comp_match,
            archives,
        )

        print(f"Timeout set to : {subprocess_timeout}")  # noqa:T001

        for team in archives.glob('*.zip'):
            tla = team.stem

            try:
                print(f"Running match for {tla}")  # noqa:T001

                match_args = [
                    sys.executable,
                    run_comp_match,
                    str(archives),
                    '0',  # no logs will be retained so a fixed match number is used
                ]

                match_args.append(tla)

                match_args.extend(['-'] * (NUM_ZONES - 1))  # all other zones are empty

                match_args.extend([
                    '--duration', '1',
                    '--no-record',
                ])

                subprocess.run(
                    match_args,
                    check=True,
                    stdout=subprocess.PIPE,  # we only want to print output from failing robots
                    stderr=subprocess.STDOUT,
                    timeout=subprocess_timeout,
                )

                print(f"Completed match for {tla}")  # noqa:T001

            except subprocess.CalledProcessError as match_errors:
                print(match_errors.output.decode())  # noqa: T001
                print(f"Failed on team {tla}")  # noqa:T001
                failed_tlas.append(tla)
            except subprocess.TimeoutExpired as match_timeout:
                print(match_timeout.output.decode())  # noqa: T001
                print(f"Timeout on team {tla}")  # noqa:T001
                failed_tlas.append(tla)

    print(f"Failing TLAs: {', '.join(failed_tlas)}")  # noqa: T001


if __name__ == '__main__':
    main(parse_args())
