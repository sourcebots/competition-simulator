#!/usr/bin/env python3
"""
A script to run a test competition match on every robot in an submissions directory.

A "broken" robot is any robot which:
- Fails to reach the wait_start function within the 5 second timeout
  set in wait_until_robots_ready, caused by:
  a. The robot code throwing an uncaught exception before instantiating the Robot
  b. The robot code taking over 5 seconds before instantiating the Robot
- Fails to complete a 1 second match within the subprocess timout
- Causes the simulator to exit with a non-zero exit code
"""
import re
import sys
import time
import shutil
import argparse
import tempfile
import subprocess
from typing import List, Optional
from pathlib import Path
from zipfile import ZipFile

REPO_ROOT = Path(__file__).resolve().parent.parent

sys.path.insert(1, str(REPO_ROOT / 'modules'))

from controller_utils import NUM_ZONES  # isort:skip

EXCESS_SUBPROCESS_TIMEOUT = 10


def run_robot_match(
    comp_match_script: Path,
    archives_dir: Path,
    tla: str,
    failed_tlas: Optional[List[str]],
    subprocess_timeout: Optional[int],
) -> int:
    try:
        print(f"Running match for {tla}")  # noqa:T001

        match_args = [
            sys.executable,
            str(comp_match_script),
            str(archives_dir),
            '0',  # no logs will be retained so a fixed match number is used
        ]

        match_args.append(tla)

        match_args.extend(['-'] * (NUM_ZONES - 1))  # all other zones are empty

        match_args.extend([
            '--duration', '1',
            '--no-record',
        ])

        start_time = time.time()
        subprocess.run(
            match_args,
            check=True,
            stdout=subprocess.PIPE,  # we only want to print output from failing robots
            stderr=subprocess.STDOUT,
            timeout=subprocess_timeout,
            text=True,
        )

        print(f"Completed match for {tla}")  # noqa:T001

    except subprocess.CalledProcessError as match_errors:
        print(match_errors.output)  # noqa: T001
        print(f"Failed on team {tla}")  # noqa:T001
        if failed_tlas is None:
            raise match_errors
        else:
            failed_tlas.append(tla)
    except subprocess.TimeoutExpired as match_timeout:
        print(match_timeout.output.decode())  # noqa: T001
        print(f"Timeout on team {tla}")  # noqa:T001
        if failed_tlas is not None:
            failed_tlas.append(tla)
    return round(time.time() - start_time)


def is_team_archive(archive: str) -> bool:
    # team archives are three uppercase letters and an optional number
    return bool(re.search(r'^[A-Z]{3}[0-9]?$', archive))


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser()
    parser.add_argument(
        'archives_dir',
        help=(
            "The directory, or archive, containing the teams' robot code, "
            "as Zip archives named for the teams' TLAs."
        ),
        type=Path,
    )
    return parser.parse_args()


def main(args: argparse.Namespace) -> None:
    failed_tlas: List[str] = []

    run_comp_match = Path(__file__).parent / 'run-comp-match'

    with tempfile.TemporaryDirectory() as tempdir_name:

        tempdir = Path(tempdir_name)
        # Make a temporary copy of the archives to receive the logs
        if args.archives_dir.is_dir():
            archives = shutil.copytree(args.archives_dir.resolve(), tempdir / 'archives')
        else:
            archives = tempdir / 'archives'
            archives.mkdir()
            with ZipFile(args.archives_dir) as zipfile:
                zipfile.extractall(archives)

        subprocess_timeout = (
            EXCESS_SUBPROCESS_TIMEOUT +
            run_robot_match(run_comp_match, archives, '-', None, None)
        )

        print(f"Timeout set to : {subprocess_timeout}")  # noqa:T001

        for team in archives.glob('*.zip'):
            tla = team.stem

            # skip non-robot archives
            if not is_team_archive(tla):
                continue

            run_robot_match(run_comp_match, archives, tla, failed_tlas, subprocess_timeout)

    print(f"Failing TLAs: {', '.join(failed_tlas)}")  # noqa: T001


if __name__ == '__main__':
    main(parse_args())
